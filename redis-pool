#!/usr/bin/env bash

# Brief: Create and keepalive N connections to Redis and bind them to a Unix socket
# Usage: ./redis-connection-pool [options] 
# Options:
#   -n <number of connections>
#   -h <host>
#   -p <port>
#   -a <passwd>
#   -t <idle timeout s>
#   -d <database no.>
# RESP responses are served over the socket; you still need to parse them with redis_read or redis_rep from redis.bash. 
# The socket just acts as a portal to the Redis-server.
# Use a connection from this pool:
#   echo <Redis command> | nc -U -N redis-socket-file-path | redis_rep # Socket I/O

. "${BASH_SOURCE%/*}/redis.bash"

while getopts ':h:p:a:t:d:n:' opt;do
  case "${opt}" in
    h) REDIS_HOST="${OPTARG}";;
    p) REDIS_PORT="${OPTARG}";;
    a) REDIS_AUTH="${OPTARG}";;
    t) REDIS_TIMEOUT="${OPTARG}";;
    d) REDIS_DB="${OPTARG}";;
    n) num_conn="${OPTARG}";;
    *) echo "Usage: ${0} [-h <host>] [-p <port>] [-a <passwd>] [-t <idle timeout s>] [-d <database no.>] [-n <no. of connections>] <socket's file-path or localhost port number>" >&2; exit;;
  esac
done
socket="${!OPTIND}"
[[ "${socket}" ]] || { echo "Pass a Unix-socket file-path or localhost TCP port number as parameter. For more help, use: ${0} -h" >&2; exit;}
if [[ "${socket}" =~ ^[0-9]*$ ]]; then
  unix_sock=false
  socketaddr="TCP4-LISTEN:${socket}"
else
  unix_sock=true
  socketaddr="UNIX-LISTEN:${socket}"
fi
num_conn="${num_conn:-1}"

single_conn(){
  local usock="${1}"
  trap "redis_disconnect; rm -f ${usock}" return
  trap '' HUP
  trap 'return' TERM QUIT INT
  redis_connect || return "$?"
  while :; do
    socat UNIX-L:"${usock}",crlf FD:"${REDIS_FD}"
  done
}

trap "${unix_sock} && rm -f ${socket}; pkill -s $$" INT QUIT TERM HUP exit

for i in $(seq ${num_conn}); do
  usock="socket-${i}"
  rm -f "${usock}"
  single_conn "${usock}" &
done

sleep 0.1 # Giving time to single_conn in bg to create the sockets

socat "${socketaddr}",reuseaddr,fork,maxchildren="${num_conn}" \
SYSTEM:'until for s in socket-*;do nc -U ${s} && break; done; do sleep 0;done'
# Note the until loop above. It makes sure every request is fed to the server even if there's an initial wait

exit
